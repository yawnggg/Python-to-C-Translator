# Assignment 2
**Due by 11:59pm on Monday, 5/13/2024**<br/>
**Demo due by 11:59pm on Monday, 5/27/2024**

In this assignment we'll work on a building parser for a small subset of the language Python.  In particular, we'll use the widely-used parser generator [Bison](https://www.gnu.org/software/bison/) to implement a parser that, when combined with the scanner we wrote in assignment 1, will implement a [syntax-directed translation scheme](https://en.wikipedia.org/wiki/Syntax-directed_translation) where the parser itself directly generates C target code from Python source code.

There are a few major parts to this assignment, described below.  To get you started, you are provided with a Flex scanner specification in `scanner.l` that solves the problem defined in assignment 1.  There is also a makefile that specifies compilation for the scanner.  An empty Bison parser specification `parser.y` is included, and this is where you'll do most of your work for this assignment.

## 1. Modify the scanner to work with Bison

Flex and Bison are designed to easily integrate with each other, but you'll still need to make some modifications to the scanner specification to make it and the parser work together.  These modifications will be easiest to do in stages:

1. Set up a basic Bison parser definition (e.g. in `parser.y`) with no nonterminals and no grammar.  The main thing you'll need to do is write `%token` directives to specify all of the terminals you'll use in your grammar.  These terminals will correspond directly to the syntactic categories we recognized by the scanner from assignment 1, e.g. `IDENTIFIER`, `FLOAT`, `WHILE`, `PLUS`, etc.  To write these `%token` directives, you'll need to figure out what data type you'll send from the scanner to the parser for lexemes in each different syntactic category.  For example, will you send `FLOAT` lexemes to the parser as `float` numbers, as `char*` representations, or as another data type?  Remember, our end goal with this project is to output C code corresponding to the Python code being parsed.  Send lexemes from the scanner to the parser in a format that makes it easy to accomplish that goal.

2. Once you have your parser definition started, you can use one of the compilation rules in the provided makefile to generate a header file containing constant integer values for all of the terminals/syntactic categories.  Specifically, you should be able to run the following command:
    ```
    make parser.h
    ```
    This will generate two files, `parser.c` and `parser.h`, the latter of which is the header file you can include in the scanner so you can start returning integer values from the scanner instead of just printing out syntactic categories.

3. Now, modify the scanner to return syntactic categories instead of printing them.  For Python, this sounds easier than it actually is.  In particular, under the default setup, a Bison-generated parser exists as a function `yyparse()`.  This function repeatedly calls the scanning function `yylex()` that's generated by our Flex specification, and, on each call, it expects `yylex()` to return the integer code for the syntactic category of the next word in the source program.

    Thus, you might be tempted to simply replace all of the `printf()` statements that print syntactic categories in the scanner into `return` statements that just return those syntactic categories instead.  This would work for all but a small few cases.  In particular, there are a few situations where a single call to the scanner function `yylex()` could result in *multiple* tokens being recognized at the same time.  Specifically, when a program is dedented by multiple levels at once, we need our scanner to be able to return multiple `DEDENT` tokens from a single Flex rule.  This cannot be done with a simple return statement.  There are at least two ways to solve this problem:

      1. **Use a queue to store tokens to return from the scanner.**  Every time a token is generated in the scanner, place it into a queue instead of returning it.  Then, at the beginning of each call to `yylex()`, first check the queue to see if there are any tokens waiting to be returned.  If there are, simply dequeue the first token and return it.  Note that under this approach, you may need to do some extra work to be able to return the *lexeme* along with each syntactic category that's returned, since this is needed for some syntactic categories like `IDENTIFIER`.  One possibility would be to store lexeme/syntactic category pairs in your queue.

      2. **Implement a push parser.**  The default model implemented by a Bison-generated parser is to "pull" tokens from the scanner by calling `yylex()` each time a new token is needed.  A push parser reverses these roles so that `yylex()` is called only once and now "pushes" a token to the parser each time a new token becomes available.  It does this by calling the function `yypush_parse()`, passing the new token as an argument.  Under the push-parsing paradigm, it doesn't matter if the scanner generates multiple tokens at a time, since each one can be pushed to the parser in turn just my calling `yypush_parse()` multiple times.  You can read more about how Bison push parsing works here:

          https://www.gnu.org/software/bison/manual/bison.html#Push-Decl

## 2. Implement grammar rules to recognize Python constructs

Once your scanner is able to generate one token at a time, either via a token queue, via push parsing, or by some other method, you are ready to write some grammar rules to recognize constructs in the Python language.  At this point, you don't need to worry about attaching actions to these rules.  You can just get your grammar in place.

The grammar you write will need to recognize a simplified subset of Python.  In particular, your grammar should be able to derive a source program comprised of the following kinds of statements:

* **Assignment statements.**  These are statements where the value of an algebraic expression is assigned to a specific variable, e.g.:
    ```python
    circumference = pi * 2 * r
    ```
    In the subset of Python we'll implement, no assignment statement will span more than a single line of code, and each statement will be terminated by a newline (i.e. lines won't be broken with a `\` character, which is possible in actual Python syntax).  The expression on the right-hand side of the assignment can be any valid algebraic expression involving identifiers, floats, integers, or booleans and the following operators: `+`, `-`, `*`, `/`, `==`, `!=`, `>`, `>=`, `<`, `<=`, `not`.  Expressions may also contain parentheses `()`.  Make sure you implement the [correct precedence order for the operators](https://docs.python.org/3/reference/expressions.html#operator-precedence).

* **If-elif-else statements.**  In Python these look like the following:
    ```python
    if a:
        x = 2 * y
    elif b <= 7:
        x = 3 * y
    else:
        x = 4 * y
    ```
    Of course, the `elif` and `else` parts are both optional.  The statement could also include more `elif` blocks.  Importantly, all of the statements to be executed for each of the `if`, `elif`, and `else` conditions are indented to the same level.  In other words, each block is contained within a matching `INDENT`/`DEDENT` pair.  For this assignment, every one of these blocks will be preceded by a newline.  In other words, another statement cannot be included on the same line as the `if`, the `elif`, or the `else`, which is possible in full Python syntax.  Also, for this assignment, the conditions for `if` and `elif` statements can be any valid expression or any boolean combination of expressions using the `and` and `or` operators.

* **While statements.**  These are similar to `if` statements, e.g.:
    ```python
    while i < 10:
        i = i + 1
    ```
    Again, the block of statements to be executed in each iteration of the while loop will be contained within a matching `INDENT`/`DEDENT` pair and will be separated from the `while` statement with a newline.  Like with `if` and `elif` blocks, the termination conditions for `while` statements can be any valid expression or any boolean combination of expressions using the `and` and `or` operators.

* **Break statements.** These simply consist of the keyword `break` followed by a newline, i.e.:
    ```python
    break
    ```

For this assignment, some things you specifically *do not* need to worry about are:
  * For loops.
  * Function definitions and function calls.
  * Arrays, dictionaries, and string constants.

## 3. Create actions to perform syntax-directed translation that generates C code from the parser

Syntax-directed translation is a translation scheme where translation is driven mainly by the parser.  Typically, this involves attaching actions to the rules of a CFG defining the source language syntax, such that each time a production in the grammar is applied to the source code, the corresponding action is executed.  In other words, syntax-directed translation is precisely what Bison allows us to implement.

Our primary goal for this assignment is to perform syntax-directed translation to generate C target code directly from the parser for a given Python source program.  In other words, your parser must output a working C program that performs the same computation as the input Python program.

Once you have your grammar defined, you can begin to attach actions to your rules to perform the translation to C.  The easiest approach here will be to use the information you gain from the rules of your grammar about constructs recognized in the source program to generate corresponding C language strings for those constructs.

For example, if a production in your grammar recognizes an algebraic expression in the Python consisting of the individual symbols "`a`", "`+`", and "`3`", then you can use those individual symbols to construct a C string representing the entire expression: "`a + 3`".

Similarly, if a production in your grammar recognizes an assignment statement consisting of the LHS variable "`b`", an equals sign "`=`", the RHS expression "`a + 3`", and a NEWLINE token, then you can generate the following C translation to represent that assignment statement: "`b = a + 3;`".  (Note the addition of the semicolon in the C translation.)

In this way, your parser will be continually taking smaller strings of code and building them into strings of code representing larger constructs, and at the end of the parse, your grammar's goal symbol will refer to a string containing the entire translated target program.

A few things to consider while you're performing the syntax-directed translation:

* Your parser should generate a *working* C program, so it will need to contain boilerplate things like `#include` statements and a `main()` function.  It will probably be easiest if you don't worry about adding things like `#include <stdio.h>` or wrapping your target program within a `main()` function until the parse is complete.  If your parser simply translates a sequence of Python statements into a corresponding sequence of C statements, you can wrap this translated sequence in a `main()` function at the very end.

* In order to generate a working C program, you'll also need a variable declaration for each variable used in the program.  To do this, you can maintain a simple symbol table where you store each variable name when it is first encountered by the parser.  When your parse is finished, you can simply iterate through the variable names stored in the symbol table and, for each one, generate a variable declaration at the top of your generated `main()` function.

    There are a couple simplifying assumptions you can make for the purposes of this assignment to make this a little easier:

    * It is an error for a variable to be used before it appears on the left-hand side of an assignment statement.  See section 4 ("Report syntax errors") below for more details on handling errors.

    * All variables can be scoped to the generated `main()` function.  You don't need to worry about scoping variables within blocks (e.g. inside of an `if` block).

    * All variables can have the same type, e.g. `double` or `float`.

* So you can tell what's happening with your translated code, you should also generate a series of `printf()` statements at the end of your `main()` function to print the final values of the variables at the end of the execution of the translated program.  For example, say you have the following simple Python program:
    ```python
    four = 2 + 2
    ```
    If you are translating to C, your parser should output a program that looks like this (though you don't need to match the indentation of this program; it's included only for clarity):
    ```c
    #include <stdio.h>
    int main() {
        double four;
        four = 2 + 2;
        printf("four: %lf\n", four);
    }
    ```

* Don't worry about indentation in your generated C program.  Everything can be unindented for simplicity.

Once you get your translation fully working, you should be able to use `gcc` to compile and run the generated target program, provided the source program contains no syntax errors.

## 4. Report syntax errors

Finally, once your parser is working on valid programs, make sure it reports syntax errors.  For partial credit, you can implement your parser so that it reports only the first error (of any type), including the line number of the error.  If an error is encountered, your parser should *not* output a C translation of the source code.

For full credit, your parser should do the following:
  * It should recognize and report all errors in the source file, including the line number of each error.
  * It should differentiate between different types of errors, including the ones listed below.  You can get partial credit for reporting errors without differentiating different error types.
    * **Invalid tokens** (e.g. `$` or `@`).  These will be recognized first by the scanner.
    * **Invalid variables**, i.e. variables used in an expression before they are defined on the left-hand side of an assignment statement.
    * **Invalid syntax**, i.e. invalid combinations of valid syntactic symbols (e.g. a missing colon after an `if`, invalid indentation, invalid ordering of code constructs, etc.).

## Compiling and running your parser

The makefile included in this starter code contains all the rules you should need to compile your parser.  However, there are a couple things to be aware of when you want to compile and run your parser:

  * Currently, `scanner.l` contains a `main()` function to run the scanner.  You may or may not need to move this `main()` function into `parser.y`.

  * While the makefile contains all the rules needed to compile your parser, they won't be executed by default when you run `make`, since the parser in the starter code won't compile out of the box.  If you want to compile the parser, you'll have to run `make parse`.  Alternatively, you can add `parse` to the list of dependencies for the `all` rule in the makefile, so you can just run `make`.

## Testing your parser

There are some simple Python programs you may use for testing your parser included in the `testing_code/` directory.  Some of these programs (i.e. `p*.py`) are syntactically valid, and your parser should be able to translate them successfully.  There are example translations for these programs included in the `example_output/` directory.  Some of the programs in `testing_code/` (i.e. `error*.py` and `multi_error*.py`) contain various different syntax errors.  Your parser should fail to translate these programs and report the syntax errors.

## Submission

We'll be using GitHub Classroom for this assignment, and you will submit your assignment via GitHub.  Make sure your completed files are committed and pushed by the assignment's deadline to the main branch of the GitHub repo that was created for you by GitHub Classroom.  A good way to check whether your files are safely submitted is to look at the main branch your assignment repo on the github.com website (i.e. https://github.com/osu-cs480-sp24/assignment-2-YourGitHubUsername/). If your changes show up there, you can consider your files submitted.

## Grading criteria

The TAs will grade your assignment by compiling and running it on one of the ENGR servers, e.g. `flip.engr.oregonstate.edu`, so you should make sure your code works as expected there.  `bison` and `flex` are installed on the ENGR servers.  If your code does not compile and run on the ENGR servers, the TAs will deduct at least 25 points from your score.

This assignment is worth 100 points total, broken down as follows:
  * 45 points: Parser implements a grammar that correctly models the subset of Python described above.
    * Only the grammar needs to be correctly written to earn these points, i.e. other parts of the parser/scanner can be incomplete or not working (e.g. parser/scanner actions, translation to C, etc.).
    * 10 points: Grammar correctly models expressions (i.e. the right-hand sides of assignment statements and conditions for `if` and `while` statements).
    * 10 points: Grammar correctly models assignment statements (excluding expressions).
    * 10 points: Grammar correctly models if/elif/else statements (excluding expressions).
    * 10 points: Grammar correctly models while loops (excluding expressions).
    * 5 points: Grammar correctly models break statements.

  * 15 points: Scanner correctly sends tokens to the parser.
    * 10 points: Scanner correctly sends single tokens to the parser, including both category and lexeme (when appropriate).
    * 5 points: Scanner correctly handles sending multiple `DEDENT` tokens from a single rule when needed.

  * 30 points: Parser correctly performs syntax-directed translation to C.
    * 15 points: Parser correctly translates all Python statements into equivalent C statements.
    * 10 points: Parser outputs a valid, executable C program, including necessary boilerplate.
    * 5 points: Output C program includes `printf()` statements to print the final values of all variables appearing in the program.

  * 10 points: Parser correctly recognizes and reports syntax errors.
    * 5 points: Parser correctly reports the first error in the program and doesn't output a C translation when an error occurs.
    * 5 points: Parser correctly recognizes and reports all errors in the source code and differentiates between these different error types (see above for more details):
      * Invalid tokens
      * Invalid variables (variables used before being defined)
      * Invalid syntax
